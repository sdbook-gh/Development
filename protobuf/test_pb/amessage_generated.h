// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AMESSAGE_TEST_FLATBUFFERS_CPP_H_
#define FLATBUFFERS_GENERATED_AMESSAGE_TEST_FLATBUFFERS_CPP_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace test {
namespace flatbuffers {
namespace cpp {

struct Submessage1;

struct Submessage2;

struct AMessage;
struct AMessageBuilder;

struct PointField;
struct PointFieldBuilder;

struct PointCloud;
struct PointCloudBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Submessage1 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t value_;

 public:
  Submessage1()
      : value_(0) {
  }
  Submessage1(int32_t _value)
      : value_(::flatbuffers::EndianScalar(_value)) {
  }
  int32_t value() const {
    return ::flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(Submessage1, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Submessage2 FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t value_;

 public:
  Submessage2()
      : value_(0) {
  }
  Submessage2(int32_t _value)
      : value_(::flatbuffers::EndianScalar(_value)) {
  }
  int32_t value() const {
    return ::flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(Submessage2, 4);

struct AMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_B = 6,
    VT_C = 8,
    VT_D = 10,
    VT_E = 12,
    VT_F = 14,
    VT_G = 16
  };
  int32_t a() const {
    return GetField<int32_t>(VT_A, 0);
  }
  int32_t b() const {
    return GetField<int32_t>(VT_B, 0);
  }
  const ::flatbuffers::Vector<int32_t> *c() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_C);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *d() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_D);
  }
  const ::flatbuffers::Vector<int8_t> *e() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_E);
  }
  const test::flatbuffers::cpp::Submessage1 *f() const {
    return GetStruct<const test::flatbuffers::cpp::Submessage1 *>(VT_F);
  }
  const ::flatbuffers::Vector<const test::flatbuffers::cpp::Submessage2 *> *g() const {
    return GetPointer<const ::flatbuffers::Vector<const test::flatbuffers::cpp::Submessage2 *> *>(VT_G);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_A, 4) &&
           VerifyField<int32_t>(verifier, VT_B, 4) &&
           VerifyOffset(verifier, VT_C) &&
           verifier.VerifyVector(c()) &&
           VerifyOffset(verifier, VT_D) &&
           verifier.VerifyVector(d()) &&
           verifier.VerifyVectorOfStrings(d()) &&
           VerifyOffsetRequired(verifier, VT_E) &&
           verifier.VerifyVector(e()) &&
           VerifyField<test::flatbuffers::cpp::Submessage1>(verifier, VT_F, 4) &&
           VerifyOffset(verifier, VT_G) &&
           verifier.VerifyVector(g()) &&
           verifier.EndTable();
  }
};

struct AMessageBuilder {
  typedef AMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_a(int32_t a) {
    fbb_.AddElement<int32_t>(AMessage::VT_A, a, 0);
  }
  void add_b(int32_t b) {
    fbb_.AddElement<int32_t>(AMessage::VT_B, b, 0);
  }
  void add_c(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> c) {
    fbb_.AddOffset(AMessage::VT_C, c);
  }
  void add_d(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> d) {
    fbb_.AddOffset(AMessage::VT_D, d);
  }
  void add_e(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> e) {
    fbb_.AddOffset(AMessage::VT_E, e);
  }
  void add_f(const test::flatbuffers::cpp::Submessage1 *f) {
    fbb_.AddStruct(AMessage::VT_F, f);
  }
  void add_g(::flatbuffers::Offset<::flatbuffers::Vector<const test::flatbuffers::cpp::Submessage2 *>> g) {
    fbb_.AddOffset(AMessage::VT_G, g);
  }
  explicit AMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AMessage>(end);
    fbb_.Required(o, AMessage::VT_E);
    return o;
  }
};

inline ::flatbuffers::Offset<AMessage> CreateAMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t a = 0,
    int32_t b = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> c = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> d = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> e = 0,
    const test::flatbuffers::cpp::Submessage1 *f = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<const test::flatbuffers::cpp::Submessage2 *>> g = 0) {
  AMessageBuilder builder_(_fbb);
  builder_.add_g(g);
  builder_.add_f(f);
  builder_.add_e(e);
  builder_.add_d(d);
  builder_.add_c(c);
  builder_.add_b(b);
  builder_.add_a(a);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AMessage> CreateAMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t a = 0,
    int32_t b = 0,
    const std::vector<int32_t> *c = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *d = nullptr,
    const std::vector<int8_t> *e = nullptr,
    const test::flatbuffers::cpp::Submessage1 *f = nullptr,
    const std::vector<test::flatbuffers::cpp::Submessage2> *g = nullptr) {
  auto c__ = c ? _fbb.CreateVector<int32_t>(*c) : 0;
  auto d__ = d ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*d) : 0;
  auto e__ = e ? _fbb.CreateVector<int8_t>(*e) : 0;
  auto g__ = g ? _fbb.CreateVectorOfStructs<test::flatbuffers::cpp::Submessage2>(*g) : 0;
  return test::flatbuffers::cpp::CreateAMessage(
      _fbb,
      a,
      b,
      c__,
      d__,
      e__,
      f,
      g__);
}

struct PointField FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIME = 4,
    VT_X = 6,
    VT_Y = 8,
    VT_Z = 10,
    VT_DISTANCE = 12,
    VT_PITCH = 14,
    VT_YAW = 16,
    VT_INTENSITY = 18,
    VT_RING = 20
  };
  uint32_t time() const {
    return GetField<uint32_t>(VT_TIME, 0);
  }
  double x() const {
    return GetField<double>(VT_X, 0.0);
  }
  double y() const {
    return GetField<double>(VT_Y, 0.0);
  }
  double z() const {
    return GetField<double>(VT_Z, 0.0);
  }
  double distance() const {
    return GetField<double>(VT_DISTANCE, 0.0);
  }
  double pitch() const {
    return GetField<double>(VT_PITCH, 0.0);
  }
  double yaw() const {
    return GetField<double>(VT_YAW, 0.0);
  }
  uint32_t intensity() const {
    return GetField<uint32_t>(VT_INTENSITY, 0);
  }
  uint32_t ring() const {
    return GetField<uint32_t>(VT_RING, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TIME, 4) &&
           VerifyField<double>(verifier, VT_X, 8) &&
           VerifyField<double>(verifier, VT_Y, 8) &&
           VerifyField<double>(verifier, VT_Z, 8) &&
           VerifyField<double>(verifier, VT_DISTANCE, 8) &&
           VerifyField<double>(verifier, VT_PITCH, 8) &&
           VerifyField<double>(verifier, VT_YAW, 8) &&
           VerifyField<uint32_t>(verifier, VT_INTENSITY, 4) &&
           VerifyField<uint32_t>(verifier, VT_RING, 4) &&
           verifier.EndTable();
  }
};

struct PointFieldBuilder {
  typedef PointField Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_time(uint32_t time) {
    fbb_.AddElement<uint32_t>(PointField::VT_TIME, time, 0);
  }
  void add_x(double x) {
    fbb_.AddElement<double>(PointField::VT_X, x, 0.0);
  }
  void add_y(double y) {
    fbb_.AddElement<double>(PointField::VT_Y, y, 0.0);
  }
  void add_z(double z) {
    fbb_.AddElement<double>(PointField::VT_Z, z, 0.0);
  }
  void add_distance(double distance) {
    fbb_.AddElement<double>(PointField::VT_DISTANCE, distance, 0.0);
  }
  void add_pitch(double pitch) {
    fbb_.AddElement<double>(PointField::VT_PITCH, pitch, 0.0);
  }
  void add_yaw(double yaw) {
    fbb_.AddElement<double>(PointField::VT_YAW, yaw, 0.0);
  }
  void add_intensity(uint32_t intensity) {
    fbb_.AddElement<uint32_t>(PointField::VT_INTENSITY, intensity, 0);
  }
  void add_ring(uint32_t ring) {
    fbb_.AddElement<uint32_t>(PointField::VT_RING, ring, 0);
  }
  explicit PointFieldBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PointField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PointField>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PointField> CreatePointField(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t time = 0,
    double x = 0.0,
    double y = 0.0,
    double z = 0.0,
    double distance = 0.0,
    double pitch = 0.0,
    double yaw = 0.0,
    uint32_t intensity = 0,
    uint32_t ring = 0) {
  PointFieldBuilder builder_(_fbb);
  builder_.add_yaw(yaw);
  builder_.add_pitch(pitch);
  builder_.add_distance(distance);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_ring(ring);
  builder_.add_intensity(intensity);
  builder_.add_time(time);
  return builder_.Finish();
}

struct PointCloud FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PointCloudBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEIGHT = 4,
    VT_WIDTH = 6,
    VT_POINT_STEP = 8,
    VT_ROW_STEP = 10,
    VT_POINTS = 12
  };
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t point_step() const {
    return GetField<uint32_t>(VT_POINT_STEP, 0);
  }
  uint32_t row_step() const {
    return GetField<uint32_t>(VT_ROW_STEP, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<test::flatbuffers::cpp::PointField>> *points() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<test::flatbuffers::cpp::PointField>> *>(VT_POINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_POINT_STEP, 4) &&
           VerifyField<uint32_t>(verifier, VT_ROW_STEP, 4) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           verifier.EndTable();
  }
};

struct PointCloudBuilder {
  typedef PointCloud Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(PointCloud::VT_HEIGHT, height, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(PointCloud::VT_WIDTH, width, 0);
  }
  void add_point_step(uint32_t point_step) {
    fbb_.AddElement<uint32_t>(PointCloud::VT_POINT_STEP, point_step, 0);
  }
  void add_row_step(uint32_t row_step) {
    fbb_.AddElement<uint32_t>(PointCloud::VT_ROW_STEP, row_step, 0);
  }
  void add_points(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<test::flatbuffers::cpp::PointField>>> points) {
    fbb_.AddOffset(PointCloud::VT_POINTS, points);
  }
  explicit PointCloudBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PointCloud> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PointCloud>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PointCloud> CreatePointCloud(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t height = 0,
    uint32_t width = 0,
    uint32_t point_step = 0,
    uint32_t row_step = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<test::flatbuffers::cpp::PointField>>> points = 0) {
  PointCloudBuilder builder_(_fbb);
  builder_.add_points(points);
  builder_.add_row_step(row_step);
  builder_.add_point_step(point_step);
  builder_.add_width(width);
  builder_.add_height(height);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PointCloud> CreatePointCloudDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t height = 0,
    uint32_t width = 0,
    uint32_t point_step = 0,
    uint32_t row_step = 0,
    const std::vector<::flatbuffers::Offset<test::flatbuffers::cpp::PointField>> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVector<::flatbuffers::Offset<test::flatbuffers::cpp::PointField>>(*points) : 0;
  return test::flatbuffers::cpp::CreatePointCloud(
      _fbb,
      height,
      width,
      point_step,
      row_step,
      points__);
}

inline const test::flatbuffers::cpp::PointCloud *GetPointCloud(const void *buf) {
  return ::flatbuffers::GetRoot<test::flatbuffers::cpp::PointCloud>(buf);
}

inline const test::flatbuffers::cpp::PointCloud *GetSizePrefixedPointCloud(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<test::flatbuffers::cpp::PointCloud>(buf);
}

inline bool VerifyPointCloudBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<test::flatbuffers::cpp::PointCloud>(nullptr);
}

inline bool VerifySizePrefixedPointCloudBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<test::flatbuffers::cpp::PointCloud>(nullptr);
}

inline void FinishPointCloudBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<test::flatbuffers::cpp::PointCloud> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPointCloudBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<test::flatbuffers::cpp::PointCloud> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace cpp
}  // namespace flatbuffers
}  // namespace test

#endif  // FLATBUFFERS_GENERATED_AMESSAGE_TEST_FLATBUFFERS_CPP_H_
