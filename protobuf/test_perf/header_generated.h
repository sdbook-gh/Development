// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_HEADER_FBS_APOLLO_COMMON_H_
#define FLATBUFFERS_GENERATED_HEADER_FBS_APOLLO_COMMON_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "error_code_generated.h"

namespace fbs {
namespace apollo {
namespace common {

struct Header;
struct HeaderBuilder;
struct HeaderT;

struct HeaderT : public ::flatbuffers::NativeTable {
  typedef Header TableType;
  double timestamp_sec = 0.0;
  std::string module_name{};
  uint32_t sequence_num = 0;
  uint64_t lidar_timestamp = 0;
  uint64_t camera_timestamp = 0;
  uint64_t radar_timestamp = 0;
  uint32_t version = 1;
  std::unique_ptr<fbs::apollo::common::StatusPbT> status{};
  std::string frame_id{};
  HeaderT() = default;
  HeaderT(const HeaderT &o);
  HeaderT(HeaderT&&) FLATBUFFERS_NOEXCEPT = default;
  HeaderT &operator=(HeaderT o) FLATBUFFERS_NOEXCEPT;
};

struct Header FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HeaderT NativeTableType;
  typedef HeaderBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP_SEC = 4,
    VT_MODULE_NAME = 6,
    VT_SEQUENCE_NUM = 8,
    VT_LIDAR_TIMESTAMP = 10,
    VT_CAMERA_TIMESTAMP = 12,
    VT_RADAR_TIMESTAMP = 14,
    VT_VERSION = 16,
    VT_STATUS = 18,
    VT_FRAME_ID = 20
  };
  /// Message publishing time in seconds.
  double timestamp_sec() const {
    return GetField<double>(VT_TIMESTAMP_SEC, 0.0);
  }
  bool mutate_timestamp_sec(double _timestamp_sec = 0.0) {
    return SetField<double>(VT_TIMESTAMP_SEC, _timestamp_sec, 0.0);
  }
  /// Module name.
  const ::flatbuffers::String *module_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODULE_NAME);
  }
  ::flatbuffers::String *mutable_module_name() {
    return GetPointer<::flatbuffers::String *>(VT_MODULE_NAME);
  }
  /// Sequence number for each message. Each module maintains its own counter
  /// for sequence_num, always starting from 1 on boot.
  uint32_t sequence_num() const {
    return GetField<uint32_t>(VT_SEQUENCE_NUM, 0);
  }
  bool mutate_sequence_num(uint32_t _sequence_num = 0) {
    return SetField<uint32_t>(VT_SEQUENCE_NUM, _sequence_num, 0);
  }
  /// Lidar Sensor timestamp for nano-second.
  uint64_t lidar_timestamp() const {
    return GetField<uint64_t>(VT_LIDAR_TIMESTAMP, 0);
  }
  bool mutate_lidar_timestamp(uint64_t _lidar_timestamp = 0) {
    return SetField<uint64_t>(VT_LIDAR_TIMESTAMP, _lidar_timestamp, 0);
  }
  /// Camera Sensor timestamp for nano-second.
  uint64_t camera_timestamp() const {
    return GetField<uint64_t>(VT_CAMERA_TIMESTAMP, 0);
  }
  bool mutate_camera_timestamp(uint64_t _camera_timestamp = 0) {
    return SetField<uint64_t>(VT_CAMERA_TIMESTAMP, _camera_timestamp, 0);
  }
  /// Radar Sensor timestamp for nano-second.
  uint64_t radar_timestamp() const {
    return GetField<uint64_t>(VT_RADAR_TIMESTAMP, 0);
  }
  bool mutate_radar_timestamp(uint64_t _radar_timestamp = 0) {
    return SetField<uint64_t>(VT_RADAR_TIMESTAMP, _radar_timestamp, 0);
  }
  /// data version
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 1);
  }
  bool mutate_version(uint32_t _version = 1) {
    return SetField<uint32_t>(VT_VERSION, _version, 1);
  }
  const fbs::apollo::common::StatusPb *status() const {
    return GetPointer<const fbs::apollo::common::StatusPb *>(VT_STATUS);
  }
  fbs::apollo::common::StatusPb *mutable_status() {
    return GetPointer<fbs::apollo::common::StatusPb *>(VT_STATUS);
  }
  const ::flatbuffers::String *frame_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FRAME_ID);
  }
  ::flatbuffers::String *mutable_frame_id() {
    return GetPointer<::flatbuffers::String *>(VT_FRAME_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_TIMESTAMP_SEC, 8) &&
           VerifyOffset(verifier, VT_MODULE_NAME) &&
           verifier.VerifyString(module_name()) &&
           VerifyField<uint32_t>(verifier, VT_SEQUENCE_NUM, 4) &&
           VerifyField<uint64_t>(verifier, VT_LIDAR_TIMESTAMP, 8) &&
           VerifyField<uint64_t>(verifier, VT_CAMERA_TIMESTAMP, 8) &&
           VerifyField<uint64_t>(verifier, VT_RADAR_TIMESTAMP, 8) &&
           VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyOffset(verifier, VT_FRAME_ID) &&
           verifier.VerifyString(frame_id()) &&
           verifier.EndTable();
  }
  HeaderT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HeaderT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Header> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HeaderT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HeaderBuilder {
  typedef Header Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_timestamp_sec(double timestamp_sec) {
    fbb_.AddElement<double>(Header::VT_TIMESTAMP_SEC, timestamp_sec, 0.0);
  }
  void add_module_name(::flatbuffers::Offset<::flatbuffers::String> module_name) {
    fbb_.AddOffset(Header::VT_MODULE_NAME, module_name);
  }
  void add_sequence_num(uint32_t sequence_num) {
    fbb_.AddElement<uint32_t>(Header::VT_SEQUENCE_NUM, sequence_num, 0);
  }
  void add_lidar_timestamp(uint64_t lidar_timestamp) {
    fbb_.AddElement<uint64_t>(Header::VT_LIDAR_TIMESTAMP, lidar_timestamp, 0);
  }
  void add_camera_timestamp(uint64_t camera_timestamp) {
    fbb_.AddElement<uint64_t>(Header::VT_CAMERA_TIMESTAMP, camera_timestamp, 0);
  }
  void add_radar_timestamp(uint64_t radar_timestamp) {
    fbb_.AddElement<uint64_t>(Header::VT_RADAR_TIMESTAMP, radar_timestamp, 0);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Header::VT_VERSION, version, 1);
  }
  void add_status(::flatbuffers::Offset<fbs::apollo::common::StatusPb> status) {
    fbb_.AddOffset(Header::VT_STATUS, status);
  }
  void add_frame_id(::flatbuffers::Offset<::flatbuffers::String> frame_id) {
    fbb_.AddOffset(Header::VT_FRAME_ID, frame_id);
  }
  explicit HeaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Header>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Header> CreateHeader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double timestamp_sec = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> module_name = 0,
    uint32_t sequence_num = 0,
    uint64_t lidar_timestamp = 0,
    uint64_t camera_timestamp = 0,
    uint64_t radar_timestamp = 0,
    uint32_t version = 1,
    ::flatbuffers::Offset<fbs::apollo::common::StatusPb> status = 0,
    ::flatbuffers::Offset<::flatbuffers::String> frame_id = 0) {
  HeaderBuilder builder_(_fbb);
  builder_.add_radar_timestamp(radar_timestamp);
  builder_.add_camera_timestamp(camera_timestamp);
  builder_.add_lidar_timestamp(lidar_timestamp);
  builder_.add_timestamp_sec(timestamp_sec);
  builder_.add_frame_id(frame_id);
  builder_.add_status(status);
  builder_.add_version(version);
  builder_.add_sequence_num(sequence_num);
  builder_.add_module_name(module_name);
  return builder_.Finish();
}

struct Header::Traits {
  using type = Header;
  static auto constexpr Create = CreateHeader;
};

inline ::flatbuffers::Offset<Header> CreateHeaderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double timestamp_sec = 0.0,
    const char *module_name = nullptr,
    uint32_t sequence_num = 0,
    uint64_t lidar_timestamp = 0,
    uint64_t camera_timestamp = 0,
    uint64_t radar_timestamp = 0,
    uint32_t version = 1,
    ::flatbuffers::Offset<fbs::apollo::common::StatusPb> status = 0,
    const char *frame_id = nullptr) {
  auto module_name__ = module_name ? _fbb.CreateString(module_name) : 0;
  auto frame_id__ = frame_id ? _fbb.CreateString(frame_id) : 0;
  return fbs::apollo::common::CreateHeader(
      _fbb,
      timestamp_sec,
      module_name__,
      sequence_num,
      lidar_timestamp,
      camera_timestamp,
      radar_timestamp,
      version,
      status,
      frame_id__);
}

::flatbuffers::Offset<Header> CreateHeader(::flatbuffers::FlatBufferBuilder &_fbb, const HeaderT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline HeaderT::HeaderT(const HeaderT &o)
      : timestamp_sec(o.timestamp_sec),
        module_name(o.module_name),
        sequence_num(o.sequence_num),
        lidar_timestamp(o.lidar_timestamp),
        camera_timestamp(o.camera_timestamp),
        radar_timestamp(o.radar_timestamp),
        version(o.version),
        status((o.status) ? new fbs::apollo::common::StatusPbT(*o.status) : nullptr),
        frame_id(o.frame_id) {
}

inline HeaderT &HeaderT::operator=(HeaderT o) FLATBUFFERS_NOEXCEPT {
  std::swap(timestamp_sec, o.timestamp_sec);
  std::swap(module_name, o.module_name);
  std::swap(sequence_num, o.sequence_num);
  std::swap(lidar_timestamp, o.lidar_timestamp);
  std::swap(camera_timestamp, o.camera_timestamp);
  std::swap(radar_timestamp, o.radar_timestamp);
  std::swap(version, o.version);
  std::swap(status, o.status);
  std::swap(frame_id, o.frame_id);
  return *this;
}

inline HeaderT *Header::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<HeaderT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Header::UnPackTo(HeaderT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = timestamp_sec(); _o->timestamp_sec = _e; }
  { auto _e = module_name(); if (_e) _o->module_name = _e->str(); }
  { auto _e = sequence_num(); _o->sequence_num = _e; }
  { auto _e = lidar_timestamp(); _o->lidar_timestamp = _e; }
  { auto _e = camera_timestamp(); _o->camera_timestamp = _e; }
  { auto _e = radar_timestamp(); _o->radar_timestamp = _e; }
  { auto _e = version(); _o->version = _e; }
  { auto _e = status(); if (_e) { if(_o->status) { _e->UnPackTo(_o->status.get(), _resolver); } else { _o->status = std::unique_ptr<fbs::apollo::common::StatusPbT>(_e->UnPack(_resolver)); } } else if (_o->status) { _o->status.reset(); } }
  { auto _e = frame_id(); if (_e) _o->frame_id = _e->str(); }
}

inline ::flatbuffers::Offset<Header> Header::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HeaderT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHeader(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Header> CreateHeader(::flatbuffers::FlatBufferBuilder &_fbb, const HeaderT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HeaderT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _timestamp_sec = _o->timestamp_sec;
  auto _module_name = _o->module_name.empty() ? 0 : _fbb.CreateString(_o->module_name);
  auto _sequence_num = _o->sequence_num;
  auto _lidar_timestamp = _o->lidar_timestamp;
  auto _camera_timestamp = _o->camera_timestamp;
  auto _radar_timestamp = _o->radar_timestamp;
  auto _version = _o->version;
  auto _status = _o->status ? CreateStatusPb(_fbb, _o->status.get(), _rehasher) : 0;
  auto _frame_id = _o->frame_id.empty() ? 0 : _fbb.CreateString(_o->frame_id);
  return fbs::apollo::common::CreateHeader(
      _fbb,
      _timestamp_sec,
      _module_name,
      _sequence_num,
      _lidar_timestamp,
      _camera_timestamp,
      _radar_timestamp,
      _version,
      _status,
      _frame_id);
}

inline const fbs::apollo::common::Header *GetHeader(const void *buf) {
  return ::flatbuffers::GetRoot<fbs::apollo::common::Header>(buf);
}

inline const fbs::apollo::common::Header *GetSizePrefixedHeader(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<fbs::apollo::common::Header>(buf);
}

inline Header *GetMutableHeader(void *buf) {
  return ::flatbuffers::GetMutableRoot<Header>(buf);
}

inline fbs::apollo::common::Header *GetMutableSizePrefixedHeader(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<fbs::apollo::common::Header>(buf);
}

inline bool VerifyHeaderBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fbs::apollo::common::Header>(nullptr);
}

inline bool VerifySizePrefixedHeaderBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fbs::apollo::common::Header>(nullptr);
}

inline void FinishHeaderBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fbs::apollo::common::Header> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedHeaderBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<fbs::apollo::common::Header> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<fbs::apollo::common::HeaderT> UnPackHeader(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fbs::apollo::common::HeaderT>(GetHeader(buf)->UnPack(res));
}

inline std::unique_ptr<fbs::apollo::common::HeaderT> UnPackSizePrefixedHeader(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<fbs::apollo::common::HeaderT>(GetSizePrefixedHeader(buf)->UnPack(res));
}

}  // namespace common
}  // namespace apollo
}  // namespace fbs

#endif  // FLATBUFFERS_GENERATED_HEADER_FBS_APOLLO_COMMON_H_
